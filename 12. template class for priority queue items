#include <iostream>
#include <string>
using namespace std;

// Template class for a Priority Queue item
template <typename T>
class PriorityQueueItem {
public:
    T data;         // Data item
    int priority;   // Priority of the item

    // Constructor to initialize the item
    PriorityQueueItem(T d, int p) : data(d), priority(p) {}

    // Overloading the <= operator to compare priorities
    bool operator<=(const PriorityQueueItem<T>& other) const {
        return priority <= other.priority; // Higher priority means lower numerical value
    }
};

// Template class for the Priority Queue
template <typename T>
class PriorityQueue {
private:
    // Node class to represent each item in the queue
    class Node {
    public:
        PriorityQueueItem<T>* item; // Pointer to the priority queue item
        Node* next;                // Pointer to the next node

        Node(PriorityQueueItem<T>* newItem) : item(newItem), next(nullptr) {}
    };

    Node* front; // Points to the front of the priority queue

public:
    // Constructor to initialize the priority queue
    PriorityQueue() : front(nullptr) {}

    // Function to add an item to the priority queue
    void enqueue(T data, int priority) {
        PriorityQueueItem<T>* newItem = new PriorityQueueItem<T>(data, priority);
        Node* newNode = new Node(newItem);

        // If the queue is empty or the new item has higher priority than the front
        if (front == nullptr || *newItem <= *(front->item)) {
            newNode->next = front;
            front = newNode;
        } else {
            // Find the correct position to insert the new item
            Node* current = front;
            while (current->next != nullptr && *(current->next->item) <= *newItem) {
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }

        cout << "Enqueued: " << data << " with priority " << priority << endl;
    }

    // Function to remove the item with the highest priority
    void dequeue() {
        if (front == nullptr) {
            cout << "Queue is empty. Cannot dequeue." << endl;
            return;
        }

        Node* temp = front;      // Temporary pointer to the front node
        front = front->next;     // Move front to the next node

        cout << "Dequeued: " << temp->item->data << " with priority " << temp->item->priority << endl;

        delete temp->item;       // Free the memory for the item
        delete temp;             // Free the memory for the node
    }

    // Function to display the priority queue items
    void display() const {
        if (front == nullptr) {
            cout << "Priority queue is empty." << endl;
            return;
        }

        Node* current = front;
        cout << "Priority Queue: ";
        while (current != nullptr) {
            cout << "(" << current->item->data << ", " << current->item->priority << ") ";
            current = current->next;
        }
        cout << endl;
    }

    // Destructor to clean up memory
    ~PriorityQueue() {
        while (front != nullptr) {
            dequeue();
        }
    }
};

int main() {
    PriorityQueue<string> pq; // Create a priority queue for strings

    // Enqueue items with different priorities
    pq.enqueue("Task 1", 3);
    pq.enqueue("Task 2", 1);
    pq.enqueue("Task 3", 2);

    // Display the priority queue
    pq.display();

    // Dequeue items
    pq.dequeue();
    pq.dequeue();

    // Display the priority queue again
    pq.display();

    return 0;
}
